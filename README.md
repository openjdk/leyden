# Leyden Early Access Release

The purpose of the Leyden Early Access Release is to prototype improvements in 
startup time, in time to peak performance, and in footprint of Java programs, as a part of 
[Project Leyden](https://openjdk.org/projects/leyden). We would like to solicit feedback from
the Java community, with the hope that some of these improvements can be eventually
incoporated in future Java releases.

## 0. Disclaimers

- *This release contains experimental and unstable code. It is not intended to be used
   in a production environment.*
- *The experimental features in this release may be changed or removed without notice.
   Command line flags and workflows are likely to change.*

## 1. Overview

The Leyden prototype includes many optimizations that shift work from run time to earlier
experimental executions of the application, which are
called <i>training runs</i>. In a training run, we pre-compute various kinds of information.
Importantly, we pre-compile
bytecode to native code, guided by observations of the application's actual behavior
during the training run.

The Leyden repository is closely tracking the JDK main-line development. We are typically only a few weeks behind
the [main-line JDK repo](https://github.com/openjdk/jdk).

We have implemented the following improvements over the JDK main-line:

- <b>[Unified Cache Data Storage (JDK-8320264)](https://openjdk.org/jeps/8320264)</b>:
  This enhancement to [CDS] is foundational to the other features.
  - It enables [CDS] to store not only class metadata and heap objects (as before),
  but also profiling data and compiled code.
  - This feature is accessed with the new VM flag `-XX:CacheDataStore`.
  - This option simplifies the creation of the CDS archive, and also the testing
  of all the prototype features listed here.
- <b>[Loaded Classes in CDS Archives (JDK-8315737)](https://openjdk.org/jeps/8315737)</b>:
  This gives
  the JVM the ability to put classes in the <i>loaded</i> state as soon the application starts up. As a result,
  we can implement many other time shifting optimizations with considerably simplified assumptions.
  - This feature is accessed with the new VM flag `-XX:+PreloadSharedClasses`.
  (Note that this flag will be renamed when JDK-8315737
    is integrated into the JDK main-line).
- <b>[Method Profiles in CDS Archives (JDK-8325147)](https://openjdk.org/jeps/8325147)</b>: We store method profiles
  from training runs in the CDS archive, thereby enabling the JIT to begin compiling earlier during warmup.
  As a result, Java application can reach peak performance faster.
  - This feature is enabled by the new VM flags `-XX:+RecordTraining` and `-XX:+ReplayTraining`.
- <b>Ahead-of-time resolution of constant pool entries</b>: the new VM flags `-XX:+ArchiveFieldReferences`,
  `-XX:+ArchiveMethodReferences` and `-XX:+ArchiveInvokeDynamic` makes it possible to resolve many
  constant pool entries during the training run. This allows the application to start up faster. Also,
  the existence of resolved constant pool entries allows the AOT compiler to generate better code.
- <b>Ahead-of-time compilation of Java methods</b>: Methods that are frequently used during the training run can be
  compiled and stored along with the CDS archive. As a result, as soon as the application starts up
  in the production run, its methods can be can be natively executed.
  - This feature is enabled by the new VM flags `-XX:+StoreCachedCode`, `-XX:+LoadCachedCode`, and `-XX:CachedCodeFile`.
  - Currently, the native code is stored in a separate file, but our plans is to eventually store the native code
    inside the CDS archive file.
- <b>Ahead-of-time generation of [Dynamic Proxies](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/reflect/Proxy.html)</b>:
  Dynamic proxies are frequently used by popular application frameworks. We can improve start-up time by generating these proxies ahead of time.
  - This feature is enabled by the new VM flag `-XX:+ArchiveDynamicProxies`.
- <b>Ahead-of-time generation of reflection data</b>: Reflection data (such as instances of
  `java.lang.reflect.Method`) are generated by the JVM to support `java.lang.reflect` operations. We can
  generate these ahead of time to improve start-up.
  - This feature is enabled by the new VM flag `-XX:+ArchiveReflectionData`.
- <b>Class Loader Lookup Cache</b>: Sometimes application frameworks may perform many repeated lookups of classes by name (with `Class.forName()`,
  etc.). This optimization allows such lookups to be done quickly without repeatedly scanning the classpath.
  - This feature is enabled by the new VM flag `-XX:+ArchiveLoaderLookupCache`.

The flag `-XX:CacheDataStore` automatically enables the whole bundle
of features listed above.  This simplifies testing of the whole
prototype.  If necessary for more detailed testing, each feature can
be individually disabled by negating its associated flag.

[CDS]: <https://docs.oracle.com/en/java/javase/22/vm/class-data-sharing.html>

## 2. Trying out Leyden Features

The easiest way to try out the Leyden features is to use the `java` program in the Leyden Early Access Release with the `-XX:CacheDataStore` flag.

Here's a small benchmark that uses the JDK's built-in
[`JavaCompiler`](https://docs.oracle.com/en/java/javase/21/docs/api/java.compiler/javax/tools/JavaCompiler.html)
class to compile some Java source files. This benchmark spends a significant amount of start-up time 
setting up the classes used by `JavaCompiler`, so it will benefit from the Leyden features.

First, download [JavacBenchApp.java](https://github.com/iklam/jdk/blob/f95f851aed3d2bf06edabab1e7c24e15f4145d0d/test/hotspot/jtreg/runtime/cds/appcds/applications/JavacBenchApp.java)
and compile it into a JAR file.

(Remember to use the `java` program from the Leyden Early Access Release.)

```
$ javac JavacBenchApp.java
$ jar cvf JavacBenchApp.jar JavacBenchApp*.class
added manifest
adding: JavacBenchApp$ClassFile.class(in = 1608) (out= 787)(deflated 51%)
adding: JavacBenchApp$FileManager.class(in = 2090) (out= 979)(deflated 53%)
adding: JavacBenchApp$SourceFile.class(in = 1351) (out= 671)(deflated 50%)
adding: JavacBenchApp.class(in = 7571) (out= 3302)(deflated 56%)
```

We can run this benchmark without any Leyden features. It takes 893 ms:

```
$ java -cp JavacBenchApp.jar JavacBenchApp 50
Generated source code for 51 classes and compiled them in 893 ms
```

Now, we can perform a <b>training run</b> and create the Leyden cache files.

<b>Note: Any files `JavacBenchApp.cds*` created by previous tests must
be deleted, before new ones are created.</b>:

```
$ rm -fv JavacBenchApp.cds*
$ java -XX:CacheDataStore=JavacBenchApp.cds -cp JavacBenchApp.jar JavacBenchApp 50
$ ls -l JavacBenchApp.cds*
-r--r--r-- 1 iklam iklam 30900224 May 20 19:21 JavacBenchApp.cds
-r--r--r-- 1 iklam iklam 16895736 May 20 19:21 JavacBenchApp.cds.code
```

Two files are created:

- `JavacBenchApp.cds`: This file contains classes, heap objects and profiling data harvested from the training run.
- `JavacBenchApp.cds.code`: This file contains AOT-compiled methods, optimized for the execution behaviors observed during the training run.
  (Data in this file will be merged into `JavacBenchApp.cds` in a future release.)

Now, we can make a <b>production run</b> of the program with the cache files. It finishes in 423 ms, or more than twice as fast as
before.

```
$ java -XX:CacheDataStore=JavacBenchApp.cds -cp JavacBenchApp.jar JavacBenchApp 50
Generated source code for 51 classes and compiled them in 423 ms
```

### Optional VM Flags

When you create the file `JavacBenchApp.cds` with the flag `-XX:CacheDataStore`,
all of the other options described
in the [Overview](#1-overview) section above are enabled by default. This ensures that you can get all the optimizations
without specifying them individually.

For diagnostic purposes, you can selectively disable some of the options:

- The `-XX:+LoadCachedCode` and `-XX:+ReplayTraining` flags affect only the production run.
- All other options affect only the training run.

For example, you can disable the loading of the AOT code during the production run. Notice that the benchmark now
starts more slowly than it did when AOT code was loaded.

```
$ java -XX:CacheDataStore=JavacBenchApp.cds -XX:-LoadCachedCode -cp JavacBenchApp.jar JavacBenchApp 50
Generated source code for 51 classes and compiled them in 647 ms
```

You can also disable AOT compilation in the training run:

```
$ rm -fv JavacBenchApp.cds*
$ java -XX:CacheDataStore=JavacBenchApp.cds -XX:-StoreCachedCode -cp JavacBenchApp.jar JavacBenchApp 50
$ ls -l JavacBenchApp.cds*
-r--r--r-- 1 iklam iklam 30277632 May 20 20:05 JavacBenchApp.cds
```

Note that the file `JavacBenchApp.cds.code` is no longer created.

## 3. Limitations of the Leyden Prototype

When trying out the Leyden, please pay attention to the following limitations.

### The Same Garbage Collector Must be Used between Training and Production Runs

The CDS archive generated by the Leyden prototype includes machine instructions that are specific to
the garbage collector. We recommend that you explicitly specify the same collector during both
training and production runs. For example:

```
# training run
$ rm -fv JavacBenchApp.cds*
$ java -XX:CacheDataStore=JavacBenchApp.cds -XX:+UseSerialGC -cp JavacBenchApp.jar JavacBenchApp 50

# production run
$ java -XX:CacheDataStore=JavacBenchApp.cds -XX:+UseSerialGC -cp JavacBenchApp.jar JavacBenchApp 50
```

Otherwise, the CDS archive may not be loaded for the production run, leading to suboptimal performance.
For example, sometimes you may perform the training run on a large development host, and then use
a container to run the application in a small production node. In the following scenario, as the collector
is not explicitly specified, the VM will automatically pick G1 for the training run, and SerialGC for the
production run (due to its limited amount of memory). The following example assumes that you have extracted the
Leyden Early Access Release under `/tmp/leyden-ea/jdk-24`.

```
# training run (uses G1 by default)
$ rm -fv JavacBenchApp.cds*
$ java -XX:CacheDataStore=JavacBenchApp.cds -cp JavacBenchApp.jar JavacBenchApp 50

# production run (uses SerialGC)
$ docker run --rm -v /tmp/leyden-ea/jdk-24/jdk:/jdk -v $(pwd):/test \
    --memory=1024m \
    container-registry.oracle.com/java/openjdk \
    bash -c 'cd /test; /jdk/bin/java -XX:CacheDataStore=JavacBenchApp.cds -cp JavacBenchApp.jar JavacBenchApp 50'
[0.001s][error][cds] CDS archive has preloaded classes. It cannot be used because GC used during dump time (G1)
                     is not the same as runtime (Serial)
[0.001s][error][cds] An error has occurred while processing the shared archive file.
[0.001s][error][cds] Unable to map shared spaces
Error occurred during initialization of VM
Unable to use shared archive.
```
### Only G1GC, SerialGC and ParallelGC are Supported

Currently, if you use any other garbage collector in combination with `-XX:CacheDataStore`, the VM will
exit with an error.

```
$ java -XX:+UseZGC -XX:CacheDataStore=foo --version
Error occurred during initialization of VM
Cannot create the CacheDataStore: UseCompressedClassPointers must be enabled, and collector
must be G1, Parallel, or Serial
```


### -Xshare:on is Enabled by default

As seen in the example immediately above, in the production run, if the CDS archive cannot be
used for any reason, the JVM will report an error and exit. This happens as if `-Xshare:on` was
specified in the command-line.

In the standard JDK, when the CDS archive cannot be used for any reason (for example, the
archive was created for a different version of the JDK), the application will
continue to run without using CDS.
This fall-back strategy ensures that the application will function correctly, though at a lower level of performance.

With the Leyden prototype, we have changed this fall-back behavior to make it easier to diagnose
performance issues. For example, when the start-up time is not as good as one would expect, we
want know whether it's caused by a misconfiguration that prevents the CDS archive
from being used, or it's caused by a deficiency in the implementation of the Leyden optimizations.

To revert to the behavior of the standard JDK, you can explicitly add `-Xshare:auto` to the command-line.

```
$ docker run --rm -v /tmp/leyden-ea/jdk-24/jdk:/jdk -v $(pwd):/test \
    --memory=1024m \
    container-registry.oracle.com/java/openjdk \
    bash -c 'cd /test; /jdk/bin/java -Xshare:auto -XX:CacheDataStore=JavacBenchApp.cds -cp JavacBenchApp.jar JavacBenchApp 50'
[0.001s][error][cds] CDS archive has preloaded classes. It cannot be used because GC used during dump time (G1)
                     is not the same as runtime (Serial)
Generated source code for 51 classes and compiled them in 831 ms
```

See [here](https://docs.oracle.com/en/java/javase/21/vm/class-data-sharing.html) for a discussion of `-Xshare:on` vs  `-Xshare:auto`.

## 4. More Documentation

Please see the [README.md file from the Leyden Repository](https://github.com/openjdk/leyden/blob/premain/README.md) for more information.
